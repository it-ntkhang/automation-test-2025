{"content":"Getting StartedWriting testsOn this pageWriting testsIntroduction​\nPlaywright tests are simple, they\n\nperform actions, and\nassert the state against expectations.\n\nThere is no need to wait for anything prior to performing an action: Playwright automatically waits for the wide range of actionability checks to pass prior to performing each action.\nThere is also no need to deal with the race conditions when performing the checks - Playwright assertions are designed in a way that they describe the expectations that need to be eventually met.\nThat's it! These design choices allow Playwright users to forget about flaky timeouts and racy checks in their tests altogether.\nYou will learn\n\nHow to write the first test\nHow to perform actions\nHow to use assertions\nHow tests run in isolation\nHow to use test hooks\n\nFirst test​\nTake a look at the following example to see how to write a test.\ntests/example.spec.tsimport { test, expect } from '@playwright/test';test('has title', async ({ page }) => {  await page.goto('https://playwright.dev/');  // Expect a title \"to contain\" a substring.  await expect(page).toHaveTitle(/Playwright/);});test('get started link', async ({ page }) => {  await page.goto('https://playwright.dev/');  // Click the get started link.  await page.getByRole('link', { name: 'Get started' }).click();  // Expects page to have a heading with the name of Installation.  await expect(page.getByRole('heading', { name: 'Installation' })).toBeVisible();});\nnoteAdd // @ts-check at the start of each test file when using JavaScript in VS Code to get automatic type checking.\nActions​\nNavigation​\nMost of the tests will start with navigating page to the URL. After that, test will be able to interact with the page elements.\nawait page.goto('https://playwright.dev/');\nPlaywright will wait for page to reach the load state prior to moving forward. Learn more about the page.goto() options.\nInteractions​\nPerforming actions starts with locating the elements. Playwright uses Locators API for that. Locators represent a way to find element(s) on the page at any moment, learn more about the different types of locators available. Playwright will wait for the element to be actionable prior to performing the action, so there is no need to wait for it to become available.\n// Create a locator.const getStarted = page.getByRole('link', { name: 'Get started' });// Click it.await getStarted.click();\nIn most cases, it'll be written in one line:\nawait page.getByRole('link', { name: 'Get started' }).click();\nBasic actions​\nThis is the list of the most popular Playwright actions. Note that there are many more, so make sure to check the Locator API section to learn more about them.\nActionDescriptionlocator.check()Check the input checkboxlocator.click()Click the elementlocator.uncheck()Uncheck the input checkboxlocator.hover()Hover mouse over the elementlocator.fill()Fill the form field, input textlocator.focus()Focus the elementlocator.press()Press single keylocator.setInputFiles()Pick files to uploadlocator.selectOption()Select option in the drop down\nAssertions​\nPlaywright includes test assertions in the form of expect function. To make an assertion, call expect(value) and choose a matcher that reflects the expectation.\nThere are many generic matchers like toEqual, toContain, toBeTruthy that can be used to assert any conditions.\nexpect(success).toBeTruthy();\nPlaywright also includes async matchers that will wait until the expected condition is met. Using these matchers allows making the tests non-flaky and resilient. For example, this code will wait until the page gets the title containing \"Playwright\":\nawait expect(page).toHaveTitle(/Playwright/);\nHere is the list of the most popular async assertions. Note that there are many more to get familiar with:\nAssertionDescriptionexpect(locator).toBeChecked()Checkbox is checkedexpect(locator).toBeEnabled()Control is enabledexpect(locator).toBeVisible()Element is visibleexpect(locator).toContainText()Element contains textexpect(locator).toHaveAttribute()Element has attributeexpect(locator).toHaveCount()List of elements has given lengthexpect(locator).toHaveText()Element matches textexpect(locator).toHaveValue()Input element has valueexpect(page).toHaveTitle()Page has titleexpect(page).toHaveURL()Page has URL\nTest Isolation​\nPlaywright Test is based on the concept of test fixtures such as the built in page fixture, which is passed into your test. Pages are isolated between tests due to the Browser Context, which is equivalent to a brand new browser profile, where every test gets a fresh environment, even when multiple tests run in a single Browser.\ntests/example.spec.tsimport { test } from '@playwright/test';test('example test', async ({ page }) => {  // \"page\" belongs to an isolated BrowserContext, created for this specific test.});test('another test', async ({ page }) => {  // \"page\" in this second test is completely isolated from the first test.});\nUsing Test Hooks​\nYou can use various test hooks such as test.describe to declare a group of tests and test.beforeEach and test.afterEach which are executed before/after each test. Other hooks include the test.beforeAll and test.afterAll which are executed once per worker before/after all tests.\ntests/example.spec.tsimport { test, expect } from '@playwright/test';test.describe('navigation', () => {  test.beforeEach(async ({ page }) => {    // Go to the starting url before each test.    await page.goto('https://playwright.dev/');  });  test('main navigation', async ({ page }) => {    // Assertions use the expect API.    await expect(page).toHaveURL('https://playwright.dev/');  });});\nWhat's Next​\n\nRun single test, multiple tests, headed mode\nGenerate tests with Codegen\nSee a trace of your tests\nExplore UI Mode\nRun tests on CI with GitHub Actions\nPreviousInstallationNextGenerating testsIntroductionFirst testActionsNavigationInteractionsBasic actionsAssertionsTest IsolationUsing Test HooksWhat's Next"}